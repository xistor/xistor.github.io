<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"><title>Linux/Unix系统编程手册-笔记5.进程 - xistor's notes</title>
<meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=Cache-Control content="no-transform"><meta http-equiv=Cache-Control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=author content="xistor"><meta name=description content="进程和程序 进程是一个运行中的程序实例，一个程序中包含了如何构建一个进程的信息，这些信息包括： 二进制格式识别信息：每个程序都包含了元信息来描述"><meta name=generator content="Hugo 0.125.7 with theme even"><link rel=canonical href=https://xistor.github.io/post/linux/the-linux-programming-interface-s5/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><link href=/sass/main.min.eb8cd9e340948c88a994e4063d81dde5ff918aac81c3224aed971e4656534bfb.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><meta property="og:url" content="https://xistor.github.io/post/linux/the-linux-programming-interface-s5/"><meta property="og:site_name" content="xistor's notes"><meta property="og:title" content="Linux/Unix系统编程手册-笔记5.进程"><meta property="og:description" content="进程和程序 进程是一个运行中的程序实例，一个程序中包含了如何构建一个进程的信息，这些信息包括： 二进制格式识别信息：每个程序都包含了元信息来描述"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2020-07-16T14:01:00+08:00"><meta property="article:modified_time" content="2023-07-01T13:16:34+08:00"><meta property="article:tag" content="Linux"><meta itemprop=name content="Linux/Unix系统编程手册-笔记5.进程"><meta itemprop=description content="进程和程序 进程是一个运行中的程序实例，一个程序中包含了如何构建一个进程的信息，这些信息包括： 二进制格式识别信息：每个程序都包含了元信息来描述"><meta itemprop=datePublished content="2020-07-16T14:01:00+08:00"><meta itemprop=dateModified content="2023-07-01T13:16:34+08:00"><meta itemprop=wordCount content="2838"><meta itemprop=keywords content="Linux"><meta name=twitter:card content="summary"><meta name=twitter:title content="Linux/Unix系统编程手册-笔记5.进程"><meta name=twitter:description content="进程和程序 进程是一个运行中的程序实例，一个程序中包含了如何构建一个进程的信息，这些信息包括： 二进制格式识别信息：每个程序都包含了元信息来描述"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script><script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>Xistor's Notes</a></div><div class=mobile-navbar-icon><span></span>
<span></span>
<span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/><li class=mobile-menu-item>Home</li></a><a href=/post/><li class=mobile-menu-item>Archives</li></a><a href=/tags/><li class=mobile-menu-item>Tags</li></a><a href=/categories/><li class=mobile-menu-item>Categories</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/ class=logo>Xistor's Notes</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/>Home</a></li><li class=menu-item><a class=menu-item-link href=/post/>Archives</a></li><li class=menu-item><a class=menu-item-link href=/tags/>Tags</a></li><li class=menu-item><a class=menu-item-link href=/categories/>Categories</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>Linux/Unix系统编程手册-笔记5.进程</h1><div class=post-meta><span class=post-time>2020-07-16</span><div class=post-category><a href=/categories/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C%E9%98%85%E8%AF%BB/>Linux系统编程手册阅读</a></div></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>Contents</h2><div class="post-toc-content always-active"><nav id=TableOfContents><ul><li><ul><li><a href=#进程和程序>进程和程序</a></li><li><a href=#进程id和父进程id>进程ID和父进程ID</a></li><li><a href=#进程的内存布局>进程的内存布局</a></li><li><a href=#虚拟内存管理>虚拟内存管理</a></li><li><a href=#栈>栈</a></li><li><a href=#环境变量>环境变量</a></li><li><a href=#非局部跳转>非局部跳转</a></li><li><a href=#exercises>Exercises</a></li></ul></li></ul></nav></div></div><div class=post-content><h3 id=进程和程序>进程和程序</h3><p>进程是一个运行中的程序实例，一个程序中包含了如何构建一个进程的信息，这些信息包括：</p><ul><li>二进制格式识别信息：每个程序都包含了元信息来描述可执行文件的格式，内核依靠这个来解释文件中的剩余信息。
历史上广泛使用的有a.out(assembler output)和之后的COFF(Common Object File Format),现在大多使用Executable and Linking Format (ELF)。</li><li>机器指令</li><li>程序入口地址：标识程序开始执行的指令的位置</li><li>data: 程序中用于初始化变量的值或者程序用到的常量</li><li>Symbol and relocation tables:描述函数或变量名称以及在程序中的位置，用于debug或dynamic linking</li><li>共享库和动态链接信息：程序文件中包含字段列出了程序运行时需要的所有共享库，以及用来载入lib的动态链接器的路径名</li><li>其他信息</li></ul><p>从系统角度来看，一个进程包括一段用户空间内存，里面有程序的代码和用到的变量等等，以及一段内核空间内存，里面维护了程序状态等信息（PID, 虚拟内存表，open file descriptors, 信号传递和处理的相关信息， 进程资源使用及限制，当前工作目录，以及其他信息）。</p><h3 id=进程id和父进程id>进程ID和父进程ID</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>pid_t</span> <span class=nf>getpid</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span> <span class=cm>/*获取进程ID*/</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>pid_t</span> <span class=nf>getppid</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span> <span class=cm>/*获取父进程ID*/</span>    
</span></span></code></pre></td></tr></table></div></div><p>Linux 内核限制PID小于等于32767,当分配的PID到达了32767，会从300开始再次分配，因为较小的PID多数为系统进程或守护进程。Linux 2.6之后可以通过/proc/sys/kernel/pid_max来调整，在64位系统上可以到2^22。</p><p>如果一个进程的父进程终止，它会变为孤儿进程，会被init“领养”，getppid()会返回init的进程号，也就是1。</p><h3 id=进程的内存布局>进程的内存布局</h3><ul><li>代码段(text):包含了程序的机器码指令，代码段只读，不同进程可以共享代码段。</li><li>initialized data segment： 保存显式初始化过的全局变量和静态变量。这些变量的值是在程序载入内存时从可执行文件内读取对的。</li><li>uninitialized data segment： 保存未显式初始化过的全局变量和静态变量。在程序启动之前，这部分内存会被初始化为0。也称BSS段。此段被和已经初始化的变量分开的原因是，当程序保存在硬盘上的时候是不需要保存这些没初始化的变量的，但进程跑起来的时候需要，而且部分空间是在程序载入内存的时候才会分配。</li><li>栈区(stack): 存储局部变量，参数，返回值。</li><li>堆(heap): 运行时动态分配的内存。</li></ul><p>size命令可以查看可执行文件的各段的大小：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>~/cpp/test/$ size
</span></span><span class=line><span class=cl>text data bss dec hex filename
</span></span><span class=line><span class=cl>2194 616 280 3090 c12 a.out
</span></span></code></pre></td></tr></table></div></div><h3 id=虚拟内存管理>虚拟内存管理</h3><p>引入虚拟内存是为了更高效的利用CPU和RAM,因为程序存在局部性。</p><ul><li>空间局部性：程序会趋向于访问最近访问过的内存地址附近的数据，因为程序指令连续，还有数据一般也是连续存储。</li><li>时间局部性：程序会趋向于访问最近访问过的同一块内存（因为程序中有循环）。</li></ul><figure class=center><img src=/img/the-linux-programming-interface-s5/vm_layout.png width=500><figcaption><h4>虚拟内存布局</h4></figcaption></figure><p>图中的argv和environ是命令行输入的参数和进程环境变量。 etext, edata, 和end可以获得程序段的地址。
使用方法,在程序中声明：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>extern</span> <span class=kt>char</span> <span class=n>etext</span><span class=p>,</span> <span class=n>edata</span><span class=p>,</span> <span class=n>end</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>虚拟内存会将程序使用的内存分成等大小的单元，称为“页”(pages)。在任意时刻只有程序需要的页才会在内存中，成为常驻内存集，其他未用的页放在硬盘上的swap区域。当程序访问到了不在物理内存上的页时会触发page fault,内核会挂起程序，将所需的页从硬盘读入到内存中。</p><figure class=center><img src=/img/the-linux-programming-interface-s5/overview_of_vm.png width=600><figcaption><h4>虚拟内存</h4></figcaption></figure><p>如图，内核会为每一个进程维护一个page table,并不是进程的所有虚拟内存地址都有对应的page table入口，通常有一大部分虚拟地址空间是没用到的。当进程试图访问没有一个没有page table入口的地址时，会收到SIGSEGV信号。</p><p>虚拟内存的好处：</p><ul><li>进程之间相互隔离，通过将每个进程的page-table指向相互分离的物理内存就可以实现。</li><li>在适当的时候，进程间可以共享内存，内核可以通过将不同进程的page-table指向同一个物理内存上的page来实现。</li><li>内存保护机制很好实现，因为page-table入口可以标记对应的页是可读、可写或者可执行。当进程间共享内存时就可以针对不同进程设置不同的内存保护等级。</li><li>程序员和编译器、链接器不必考虑程序在RAM中的物理布局。</li><li>程序只需要一部分常驻内存，程序加载运行将更快。</li></ul><h3 id=栈>栈</h3><p>栈是随着函数调用和返回自动增长缩小的，存在一个特殊的寄存器stack pointer跟踪当前的栈顶。
在大多数实现中，栈帧被释放后并不会还给系统，而是留着复用。
user 栈里主要有两种信息：</p><ul><li>函数参数和局部变量。</li><li>调用信息：函数会使用特定的CPU 寄存器，比如程序计数器(program counter)，当函数调用其他函数时，会把寄存器copy一份保存到栈中，以便在调用返回时恢复寄存器。</li></ul><h3 id=环境变量>环境变量</h3><p>每个进程会收到一份其父进程的环境变量拷贝。
在c程序中访问环境变量：</p><ul><li>使用全局变量 <code>char **environ</code> 访问环境列表。</li><li>在main()函数参数中添加声明</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[],</span> <span class=kt>char</span> <span class=o>*</span><span class=n>envp</span><span class=p>[])</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>getenv()函数从进程环境中检索单个值</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>char</span> <span class=o>*</span><span class=nf>getenv</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>name</span><span class=p>);</span> <span class=c1>// 返回指向字符串的指针，若没找到为NULL
</span></span></span></code></pre></td></tr></table></div></div><h3 id=非局部跳转>非局部跳转</h3><p>c 中的goto语句可以在函数内部跳转，setjmp()和longjmp()提供跨越函数跳转的功能。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;setjmp.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>setjmp</span><span class=p>(</span><span class=n>jmp_buf</span> <span class=n>env</span><span class=p>);</span>  <span class=cm>/*第一次调用返回0， 通过longjmp()返回的为longjmp()的参数val指定的非零值*/</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>longjmp</span><span class=p>(</span><span class=n>jmp_buf</span> <span class=n>env</span><span class=p>,</span> <span class=kt>int</span> <span class=n>val</span><span class=p>);</span> <span class=cm>/*若val为0会被替换成1*/</span>
</span></span></code></pre></td></tr></table></div></div><p>setjmp()调用为后续由longjmp()调用执行的跳转确立了跳转目标，即调用longjmp()会跳到setjmp()调用的位置。setjmp()两次被调用的区别在于返回值不同。</p><p>setjmp函数的使用限制：</p><ul><li>构成选择或迭代语句中(if、switch、while等)的整个控制表达式</li><li>作为一元操作符!(not)的操作对象，其最终表达式构成了选择或迭代语句的整个控制表达式。</li><li>作为比较（==、!=、&lt;）等的一部分，另一操作对象必须是一个整数常量表达式，且其最终表达式构成了选择或迭代语句的整个控制表达式。</li><li>作为独立函数调用</li></ul><p><code>s = setjmp(env);</code>语句是不符合标准的。</p><p>之所以有这些限制，是因为作为常规函数的setjmp()实现无法保证拥有足够的信息来保存所有寄存器值和封闭表达式中用到的临时栈位置，因此，仅允许在足够简单且无需临时存储的表达式中调用setjmp()。</p><p>滥用longjmp():<br>longjmp()的调用不能跳转到一个已经返回的函数，因为函数返回后，env中保存的栈信息已经失效了。</p><p>编译器优化<br>优化器对代码的优化会受到longjmp() 干扰，因此最好将局部变量声明为volatile，但最好尽可能避免使用setjmp()和longjmp()。</p><h3 id=exercises>Exercises</h3><ol><li>编译后的mem_segments使用ll查看结果：</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>-rwxr-xr-x  1 x x 11624 Jul 20 23:35 mem_segments*
</span></span></code></pre></td></tr></table></div></div><p>使用命令<code>size mem_segments</code>查看：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>text	   data	    bss	        dec	        hex	    filename
</span></span><span class=line><span class=cl>1918	   636	    10305568	10308122	9d4a1a	mem_segments
</span></span></code></pre></td></tr></table></div></div><p>可见bss区的大小已经10305568字节(大约9.8M)了,原因是bss段保存未初始化的全局变量和静态变量，当程序保存在硬盘上的时候是不需要保存这些没初始化的变量的，其空间是在程序载入内存的时候才会分配。</p></div><div class=post-copyright><p class=copyright-item><span class=item-title>Author</span>
<span class=item-content>xistor</span></p><p class=copyright-item><span class=item-title>LastMod</span>
<span class=item-content>2023-07-01
<a href=https://github.com/xistor/My-blog-source/commit/6efe40a6d4464175334353fcb55ddada241bdcb8 title="resize img">(6efe40a)</a></span></p><p class=copyright-item><span class=item-title>License</span>
<span class=item-content><a rel="license noopener" href=https://creativecommons.org/licenses/by-nc/2.0/ target=_blank>CC BY-NC 2.0</a></span></p></div><footer class=post-footer><div class=post-tags><a href=/tags/linux/>Linux</a></div><nav class=post-nav><a class=prev href=/post/linux/the-linux-programming-interface-s6/><i class="iconfont icon-left"></i>
<span class="prev-text nav-default">Linux/Unix系统编程手册-笔记6.内存分配</span>
<span class="prev-text nav-mobile">Prev</span>
</a><a class=next href=/post/linux/the-linux-programming-interface-s4/><span class="next-text nav-default">Linux/Unix系统编程手册-笔记4.深入探究文件I/O</span>
<span class="next-text nav-mobile">Next</span>
<i class="iconfont icon-right"></i></a></nav></footer></article></div><div id=disqus_thread></div><script type=text/javascript>(function(){if(window.location.hostname==="localhost")return;var t,e=document.createElement("script");e.type="text/javascript",e.async=!0,t="xistor",e.src="//"+t+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)})()</script><noscript>Please enable JavaScript to view the <a href=http://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></div></main><footer id=footer class=footer><div class=social-links><a href=mailto:xueluqiang@gmail.com class="iconfont icon-email" title=email></a><a href=https://github.com/xistor class="iconfont icon-github" title=github></a><a href=https://xistor.github.io/index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a></div><div class=copyright><span class=power-by>Powered by <a class=hexo-link href=https://gohugo.io>Hugo</a>
</span><span class=division>|</span>
<span class=theme-info>Theme -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a></span><div class=busuanzi-footer><span id=busuanzi_container_site_pv>site pv: <span id=busuanzi_value_site_pv><img src=/img/spinner.svg alt=spinner.svg></span> </span><span class=division>|</span>
<span id=busuanzi_container_site_uv>site uv: <span id=busuanzi_value_site_uv><img src=/img/spinner.svg alt=spinner.svg></span></span></div><span class=copyright-year>&copy;
2018 -
2024<span class=heart><i class="iconfont icon-heart"></i></span><span>xistor</span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src=https://cdn.jsdelivr.net/npm/jquery@3.5.0/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/raphael@2.2.7/raphael.min.js integrity="sha256-67By+NpOtm9ka1R6xpUefeGOY8kWWHHRAKlvaTJ7ONI=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/flowchart.js@1.8.0/release/flowchart.min.js integrity="sha256-zNGWjubXoY6rb5MnmpBNefO0RgoVYfle9p0tvOQM+6k=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.js integrity="sha256-4O4pS1SH31ZqrSO2A/2QJTVjTPqVe+jnYgOWUVr7EEc=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/snapsvg@0.5.1/dist/snap.svg-min.js integrity="sha256-oI+elz+sIm+jpn8F/qEspKoKveTc5uKeFHNNVexe6d8=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/underscore@1.8.3/underscore-min.js integrity="sha256-obZACiHd7gkOk9iIL/pimWMTJ4W/pBsKu+oZnSeBIek=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/gh/bramp/js-sequence-diagrams@2.0.1/dist/sequence-diagram-min.js integrity=sha384-8748Vn52gHJYJI0XEuPB2QlPVNUkJlJn9tHqKec6J3q2r9l8fvRxrgn/E5ZHV0sP crossorigin=anonymous></script><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/bramp/js-sequence-diagrams@2.0.1/dist/sequence-diagram-min.css integrity=sha384-6QbLKJMz5dS3adWSeINZe74uSydBGFbnzaAYmp+tKyq60S7H2p6V7g1TysM5lAaF crossorigin=anonymous><script type=text/javascript src=/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js></script><script type=text/javascript>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]}}</script><script async src=https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-M23R6PBNFE"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-M23R6PBNFE")}</script></body></html>