<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on xistor's note</title><link>https://xistor.github.io/post/</link><description>Recent content in Posts on xistor's note</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Sat, 01 Jan 2022 21:26:16 +0800</lastBuildDate><atom:link href="https://xistor.github.io/post/index.xml" rel="self" type="application/rss+xml"/><item><title>qemu xv6 使用GDB调试</title><link>https://xistor.github.io/post/6.s081/xv6-gdb/</link><pubDate>Sat, 01 Jan 2022 21:26:16 +0800</pubDate><guid>https://xistor.github.io/post/6.s081/xv6-gdb/</guid><description>Fall 2021 6.S081中视频还是20年的，用的GDB调试的部分没有看到比较清除的配置过程，整理了下配置过程。 1. riscv64-unknown-elf-gdb 2020 Lecture 5 视频中用的riscv64-u</description></item><item><title>docker transmission 下载没速度</title><link>https://xistor.github.io/post/rpi-docker-transmission-issue/</link><pubDate>Sat, 11 Sep 2021 01:03:16 +0800</pubDate><guid>https://xistor.github.io/post/rpi-docker-transmission-issue/</guid><description>raspberrypi下用docker部署transmission，用的是LinuxServer的image:https://hub.doc</description></item><item><title>Failed to connect to ESP32: Timed out waiting for packet header</title><link>https://xistor.github.io/post/esp/esp32-cam-fatal-error/</link><pubDate>Tue, 31 Aug 2021 21:56:16 +0800</pubDate><guid>https://xistor.github.io/post/esp/esp32-cam-fatal-error/</guid><description>20几块淘宝淘了一块Esp32-Cam, 网上也有很多配置教程， 环境配置没有什么大的问题，但在烧写固件的时候遇到了下面的错误： Looking for upload port... Auto-detected: /dev/ttyUSB0 Uploading .pio/build/nodemcu-32s/firmware.bin</description></item><item><title>IKEV2 vpn 配置备忘</title><link>https://xistor.github.io/post/ipsec-config/</link><pubDate>Thu, 26 Aug 2021 23:03:16 +0800</pubDate><guid>https://xistor.github.io/post/ipsec-config/</guid><description>1. 首先用这位同学的一键脚本完成安装及部分配置工作：https://github.com/quericy/one-key-ikev2-vpn 2.</description></item><item><title>ptrace 笔记</title><link>https://xistor.github.io/post/linux/ptrace/</link><pubDate>Tue, 02 Mar 2021 22:01:00 +0800</pubDate><guid>https://xistor.github.io/post/linux/ptrace/</guid><description>笔记主要参考Playing with ptrace， 原文比较久远，而且是在程序是在32位机器上跑的，修改成了64位机器能正确运行的版本。 ptrace() 系统调用提供</description></item><item><title>Linux/Unix系统编程手册-笔记35. Sockets</title><link>https://xistor.github.io/post/linux/the-linux-programming-interface-s35/</link><pubDate>Tue, 12 Jan 2021 18:05:00 +0800</pubDate><guid>https://xistor.github.io/post/linux/the-linux-programming-interface-s35/</guid><description>Socket系统调用： socket()创建一个新的socket bind()将socket绑定到一个地址。 listen() 系统调用允许一个流socket接受</description></item><item><title>Linux/Unix系统编程手册-笔记34. POSIX IPC</title><link>https://xistor.github.io/post/linux/the-linux-programming-interface-s34/</link><pubDate>Thu, 31 Dec 2020 00:05:00 +0800</pubDate><guid>https://xistor.github.io/post/linux/the-linux-programming-interface-s34/</guid><description>POSIX 提供的三种IPC和System V类似，分别是消息队列、信号量、共享内存。 和System V 比较优势在于： 接口更简单,如下图 使用名字代替key</description></item><item><title>Linux/Unix系统编程手册-笔记33. 内存映射</title><link>https://xistor.github.io/post/linux/the-linux-programming-interface-s33/</link><pubDate>Sat, 26 Dec 2020 18:47:00 +0800</pubDate><guid>https://xistor.github.io/post/linux/the-linux-programming-interface-s33/</guid><description>概念 mmap()内存映射有两种： 文件映射： 将一个文件的一部分直接映射到调用进程的虚拟内存中，映射的分页会按需要从文件中自动加载。 匿名映射： 没</description></item><item><title>Linux/Unix系统编程手册-笔记32. System V 共享内存</title><link>https://xistor.github.io/post/linux/the-linux-programming-interface-s32/</link><pubDate>Wed, 23 Dec 2020 18:30:00 +0800</pubDate><guid>https://xistor.github.io/post/linux/the-linux-programming-interface-s32/</guid><description>共享内存的读写比较简单，而且速度快，但需要访问同步手段，一般和信号量一起使用。 使用System V 共享内存步骤,一般分以下几个步骤： 调用shm</description></item><item><title>Linux/Unix系统编程手册-笔记31. System V 信号量</title><link>https://xistor.github.io/post/linux/the-linux-programming-interface-s31/</link><pubDate>Thu, 17 Dec 2020 18:30:00 +0800</pubDate><guid>https://xistor.github.io/post/linux/the-linux-programming-interface-s31/</guid><description>信号量和其他sys v IPC不同，它不是用来传输数据的，它是用来进程间同步的。 信号量是一个由内核维护的整数，其值被限制为大于等于0。下图是两个</description></item><item><title>Linux/Unix系统编程手册-笔记30. System V 消息队列</title><link>https://xistor.github.io/post/linux/the-linux-programming-interface-s30/</link><pubDate>Mon, 14 Dec 2020 18:30:00 +0800</pubDate><guid>https://xistor.github.io/post/linux/the-linux-programming-interface-s30/</guid><description>API msgsnd #include &amp;lt;sys/types.h&amp;gt; /* For portability */#include &amp;lt;sys/msg.h&amp;gt;int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg); // Returns 0 on success, or –1 on error msgp是一个自定义的消息数据结构，这个结构体里一定要定义一个mtype域来表示消息</description></item><item><title>Linux/Unix系统编程手册-笔记29. System V IPC</title><link>https://xistor.github.io/post/linux/the-linux-programming-interface-s29/</link><pubDate>Wed, 02 Dec 2020 18:30:00 +0800</pubDate><guid>https://xistor.github.io/post/linux/the-linux-programming-interface-s29/</guid><description>System V IPC 代表了三种进程间通信机制，他们在同一时期开发，拥有相似的API。 消息队列(Message queues)：用于在进程间传递消息，和管道类</description></item><item><title>Linux/Unix系统编程手册-笔记28. 管道</title><link>https://xistor.github.io/post/linux/the-linux-programming-interface-s28/</link><pubDate>Fri, 27 Nov 2020 18:30:00 +0800</pubDate><guid>https://xistor.github.io/post/linux/the-linux-programming-interface-s28/</guid><description>管道的概念 管道一般用于在shell中将一个进程的输出作为另一个进程的输入。比如 $ ls | wc -l 管道是一个字节流，只能按顺序读取任意大小的数据，不能</description></item><item><title>Linux/Unix系统编程手册-笔记27. 共享库</title><link>https://xistor.github.io/post/linux/the-linux-programming-interface-s27/</link><pubDate>Mon, 23 Nov 2020 18:30:00 +0800</pubDate><guid>https://xistor.github.io/post/linux/the-linux-programming-interface-s27/</guid><description>静态库是一个归档(archives),可以使用ar命令生成： $ ar options archive object-file... 静态库会被整个拷贝到可执行文件中。 创建动态库 书中给的命令分两步 $ gcc -g -c</description></item><item><title>Linux/Unix系统编程手册-笔记26. 守护进程</title><link>https://xistor.github.io/post/linux/the-linux-programming-interface-s26/</link><pubDate>Thu, 19 Nov 2020 18:30:00 +0800</pubDate><guid>https://xistor.github.io/post/linux/the-linux-programming-interface-s26/</guid><description>守护进程指常驻后台，没有控制终端的进程。 创建守护进程 执行fork(), 父进程退出，子进程变成init的子进程继续运行，这步有两个原因： 假设守</description></item><item><title>Linux/Unix系统编程手册-笔记25. 进程优先级和进程调度</title><link>https://xistor.github.io/post/linux/the-linux-programming-interface-s25/</link><pubDate>Thu, 05 Nov 2020 18:30:00 +0800</pubDate><guid>https://xistor.github.io/post/linux/the-linux-programming-interface-s25/</guid><description>nice值 nice值是进程的一个属性，可以间接影响内核调度，其值的范围为-20到+19，默认值为0。只有特权用户可以设置更高的优先级，其他用</description></item><item><title>Linux/Unix系统编程手册-笔记24. 进程组、会话和作业控制</title><link>https://xistor.github.io/post/linux/the-linux-programming-interface-s24/</link><pubDate>Sat, 31 Oct 2020 17:40:00 +0800</pubDate><guid>https://xistor.github.io/post/linux/the-linux-programming-interface-s24/</guid><description>进程组是一组相关进程的集合，会话是一组相关进程组的集合。 进程组和会话是用来支持shell作业控制的，创建进程组的目的是方便管理，可以向一个进</description></item><item><title>Linux/Unix系统编程手册-笔记23. 线程</title><link>https://xistor.github.io/post/linux/the-linux-programming-interface-s23/</link><pubDate>Sun, 18 Oct 2020 18:30:00 +0800</pubDate><guid>https://xistor.github.io/post/linux/the-linux-programming-interface-s23/</guid><description>本章主要介绍了POSIX线程， 也就是pthread。一个进程可以包含多个线程，线程之间共享全局内存。 多线程相比多进程有几个优点： 共享信息简单</description></item><item><title>Linux/Unix系统编程手册-笔记22. 程序的执行</title><link>https://xistor.github.io/post/linux/the-linux-programming-interface-s22/</link><pubDate>Mon, 12 Oct 2020 23:30:00 +0800</pubDate><guid>https://xistor.github.io/post/linux/the-linux-programming-interface-s22/</guid><description>exec() 系统调用execve()将新程序加载到某一进程的内存空间。 #include &amp;lt;unistd.h&amp;gt; int execve(const char *pathname, char *const argv[], char *const envp[]); pathname 为指定程序的路径名 argv为传递给新进程的命令行参数 e</description></item><item><title>Linux/Unix系统编程手册-笔记21. 进程的创建、终止</title><link>https://xistor.github.io/post/linux/the-linux-programming-interface-s21/</link><pubDate>Fri, 25 Sep 2020 18:21:00 +0800</pubDate><guid>https://xistor.github.io/post/linux/the-linux-programming-interface-s21/</guid><description>进程这部分主要有几个点：进程的创建、进程的终止、父进程和子进程之间的关系等。开局先来一张图 图中把fork()、exec()、wait()、e</description></item><item><title>网易云音乐在高分辨率下缩放问题</title><link>https://xistor.github.io/post/neteasy-music-in-hdpi/</link><pubDate>Sat, 12 Sep 2020 16:42:00 +0800</pubDate><guid>https://xistor.github.io/post/neteasy-music-in-hdpi/</guid><description>Linux下没几个好用的网络音乐播放器，网抑云算良心了，但是在高分屏下字体太小，根据几个博文修改--force-device-scale-f</description></item><item><title>Linux/Unix系统编程手册-笔记20.定时器与休眠</title><link>https://xistor.github.io/post/linux/the-linux-programming-interface-s20/</link><pubDate>Wed, 02 Sep 2020 18:21:00 +0800</pubDate><guid>https://xistor.github.io/post/linux/the-linux-programming-interface-s20/</guid><description>间隔计时器 使用setitimer()，一个进程可以创建三种不同类型的定时器。 #include &amp;lt;sys/time.h&amp;gt;int setitimer(int which, const struct itimerval *new_value,struct itimerval *old_value); // Returns 0 on success, or –1 on error 参数which指定不同的</description></item><item><title>AOSP组入Google Apps</title><link>https://xistor.github.io/post/add_opengapps_to_aosp/</link><pubDate>Sun, 30 Aug 2020 10:56:16 +0800</pubDate><guid>https://xistor.github.io/post/add_opengapps_to_aosp/</guid><description>自己编译好的AOSP是不包括GMS(Google Mobile Services)的，不太方便玩耍，但是有OpenGApps可以用。 官网： https://opengapps.org/ github: https://github.com/opengapps/aosp_build 环境： AO</description></item><item><title>Linux/Unix系统编程手册-笔记19.信号</title><link>https://xistor.github.io/post/linux/the-linux-programming-interface-s19/</link><pubDate>Fri, 28 Aug 2020 18:20:00 +0800</pubDate><guid>https://xistor.github.io/post/linux/the-linux-programming-interface-s19/</guid><description>信号通常用来通知某个事件发生，一个进程(有合适的权限的话)可以给另外的进程发送信号，但大多数情况下信号是由kernel发送给进程的。 信号和软</description></item><item><title>Linux/Unix系统编程手册-笔记18.监控文件事件</title><link>https://xistor.github.io/post/linux/the-linux-programming-interface-s18/</link><pubDate>Tue, 25 Aug 2020 18:25:00 +0800</pubDate><guid>https://xistor.github.io/post/linux/the-linux-programming-interface-s18/</guid><description>这章就只介绍了inotify机制,用来监控某个目录下的文件变化。直接看例程比较简单直接： #include &amp;lt;sys/inotify.h&amp;gt;#include &amp;lt;limits.h&amp;gt;#include &amp;#34;tlpi_hdr.h&amp;#34;static void /* 这一坨函数只是打印出变化事件 */ displayInotifyEvent(struct inotify_event *i) { printf(&amp;#34;</description></item><item><title>Linux/Unix系统编程手册-笔记17.目录和链接</title><link>https://xistor.github.io/post/linux/the-linux-programming-interface-s17/</link><pubDate>Thu, 20 Aug 2020 18:25:00 +0800</pubDate><guid>https://xistor.github.io/post/linux/the-linux-programming-interface-s17/</guid><description>目录和硬链接 目录和文件在文件系统中大抵按照相同的方式存储，主要有两个不同点： 目录在i-node信息中会被标注成&amp;quot;目录&amp;quot; 目</description></item><item><title>Linux/Unix系统编程手册-笔记16.访问控制列表</title><link>https://xistor.github.io/post/linux/the-linux-programming-interface-s16/</link><pubDate>Wed, 19 Aug 2020 22:40:00 +0800</pubDate><guid>https://xistor.github.io/post/linux/the-linux-programming-interface-s16/</guid><description>访问控制列表即 ACL(access control list)是对传统UNIX文件权限模型的扩展，籍此可以在每个用户或每组的基础上来控制对文件的访问。访问控制列表是利用文件扩</description></item><item><title>Linux/Unix系统编程手册-笔记15.扩展属性</title><link>https://xistor.github.io/post/linux/the-linux-programming-interface-s15/</link><pubDate>Mon, 17 Aug 2020 15:25:00 +0800</pubDate><guid>https://xistor.github.io/post/linux/the-linux-programming-interface-s15/</guid><description>概述 文件的扩展属性(extended attributes, EAs), 允许我们给文件添加自定义的键值对属性，可以以此记录文件版本、MMIE类型信息、或文件字符编码等。 扩展</description></item><item><title>Linux/Unix系统编程手册-笔记14.文件属性</title><link>https://xistor.github.io/post/linux/the-linux-programming-interface-s14/</link><pubDate>Sat, 15 Aug 2020 23:37:00 +0800</pubDate><guid>https://xistor.github.io/post/linux/the-linux-programming-interface-s14/</guid><description>获取文件信息 #include &amp;lt;sys/stat.h&amp;gt; int stat(const char *pathname, struct stat * statbuf); int lstat(const char *pathname, struct stat * statbuf); int fstat(int fd, struct stat *statbuf); 通过以上三个系统调用可以获取文件属性，它们大多数提取自i-node。 lstat(</description></item><item><title>Pixel3 解锁bootloader</title><link>https://xistor.github.io/post/unlock-the-pixel3-bootloader/</link><pubDate>Sat, 15 Aug 2020 09:55:16 +0800</pubDate><guid>https://xistor.github.io/post/unlock-the-pixel3-bootloader/</guid><description>参考官方教程 https://source.android.com/setup/build/running step1 a. 进入手机设置(setting)-&amp;gt;关于手机(about phone)-&amp;gt;点击版本号(Build number) 7次 b. 输入PIN</description></item><item><title>Linux/Unix系统编程手册-笔记13.文件系统</title><link>https://xistor.github.io/post/linux/the-linux-programming-interface-s13/</link><pubDate>Tue, 11 Aug 2020 09:49:00 +0800</pubDate><guid>https://xistor.github.io/post/linux/the-linux-programming-interface-s13/</guid><description>设备文件 一个设备文件对应一个设备，这个设备可以是真实的设备(鼠标、键盘、磁盘等)，也可以是虚拟设备。 设备分两种： 字符设备： 以字符为单位处理数</description></item><item><title>Linux/Unix系统编程手册-笔记12.文件I/O缓冲</title><link>https://xistor.github.io/post/linux/the-linux-programming-interface-s12/</link><pubDate>Mon, 10 Aug 2020 10:53:00 +0800</pubDate><guid>https://xistor.github.io/post/linux/the-linux-programming-interface-s12/</guid><description>Overview 首先看书中的一张图，就对文件I/O缓冲有个大概的了解了： 由图所示I/O缓冲分两个层次 用户空间缓冲区，stdio的输入输出函数内部所使用的缓</description></item><item><title>Linux/Unix系统编程手册-笔记11.系统和进程信息</title><link>https://xistor.github.io/post/linux/the-linux-programming-interface-s11/</link><pubDate>Sun, 09 Aug 2020 16:57:00 +0800</pubDate><guid>https://xistor.github.io/post/linux/the-linux-programming-interface-s11/</guid><description>现代Linux提供了/proc虚拟文件系统，开放了许多内核信息，允许进程方便的读取信息或者在某些情况下修改一些信息。/proc并不存在于磁盘</description></item><item><title>Linux/Unix系统编程手册-笔记10.系统限制和选项</title><link>https://xistor.github.io/post/linux/the-linux-programming-interface-s10/</link><pubDate>Mon, 03 Aug 2020 10:53:00 +0800</pubDate><guid>https://xistor.github.io/post/linux/the-linux-programming-interface-s10/</guid><description>系统限制和选项在不同系统实现、不同的运行环境、不同的文件系统之间可能存在不同。 程序获取限制值有两种途径： 在编译程序时能获得一些限制和选项，例</description></item><item><title>Linux/Unix系统编程手册-笔记9.时间</title><link>https://xistor.github.io/post/linux/the-linux-programming-interface-s9/</link><pubDate>Thu, 30 Jul 2020 10:53:00 +0800</pubDate><guid>https://xistor.github.io/post/linux/the-linux-programming-interface-s9/</guid><description>直接看书上的例子吧：获取时间并转换成多种形式显示。加了些注释。 #include &amp;lt;locale.h&amp;gt;#include &amp;lt;time.h&amp;gt;#include &amp;lt;sys/time.h&amp;gt;#include &amp;#34;tlpi_hdr.h&amp;#34; #define SECONDS_IN_TROPICAL_YEAR (365.24219 * 24 * 60 * 60) int main(int argc, char *argv[]) { time_t t; struct tm *gmp, *locp; struct tm gm, loc; struct timeval tv; /* Retrieve time, convert and display</description></item><item><title>Linux/Unix系统编程手册-笔记8.进程信任状态</title><link>https://xistor.github.io/post/linux/the-linux-programming-interface-s8/</link><pubDate>Tue, 28 Jul 2020 10:53:00 +0800</pubDate><guid>https://xistor.github.io/post/linux/the-linux-programming-interface-s8/</guid><description>每个进程有一组相关的UID和GID: 真实用户ID(real user ID)和组ID 有效用户ID(effective user ID)和组ID 保存的set-us</description></item><item><title>Linux/Unix系统编程手册-笔记7.用户和组</title><link>https://xistor.github.io/post/linux/the-linux-programming-interface-s7/</link><pubDate>Mon, 27 Jul 2020 10:53:00 +0800</pubDate><guid>https://xistor.github.io/post/linux/the-linux-programming-interface-s7/</guid><description>本章没啥好说的，比较有意思的的是crypt()函数，可以用来做用户身份鉴别： #define _XOPEN_SOURCE #include &amp;lt;unistd.h&amp;gt;char *crypt(const char *key, const char *salt); /* Returns pointer to statically allocated string containing encrypted password on success, or NULL on error */ crypt</description></item><item><title>Linux/Unix系统编程手册-笔记6.内存分配</title><link>https://xistor.github.io/post/linux/the-linux-programming-interface-s6/</link><pubDate>Sat, 25 Jul 2020 10:53:00 +0800</pubDate><guid>https://xistor.github.io/post/linux/the-linux-programming-interface-s6/</guid><description>在堆上分配内存 系统提供了两个改变堆大小的系统调用：brk()和sbrk() int brk(void *end_data_segment); // return 0 on success or -1 on error void *sbrk(intptr_t increment); // return previous progrom break on success, or (void *) -1 on error brk()</description></item><item><title>Linux/Unix系统编程手册-笔记5.进程</title><link>https://xistor.github.io/post/linux/the-linux-programming-interface-s5/</link><pubDate>Thu, 16 Jul 2020 14:01:00 +0800</pubDate><guid>https://xistor.github.io/post/linux/the-linux-programming-interface-s5/</guid><description>进程和程序 进程是一个运行中的程序实例，一个程序中包含了如何构建一个进程的信息，这些信息包括： 二进制格式识别信息：每个程序都包含了元信息来描述</description></item><item><title>Linux/Unix系统编程手册-笔记4.深入探究文件I/O</title><link>https://xistor.github.io/post/linux/the-linux-programming-interface-s4/</link><pubDate>Sun, 12 Jul 2020 16:01:00 +0800</pubDate><guid>https://xistor.github.io/post/linux/the-linux-programming-interface-s4/</guid><description>原子操作与竞争条件 创建文件 当同时指定O_EXCL和O_CREAT作为open()的标志位时，如果要打开文件已然存在，open()将返回一个错</description></item><item><title>Linux/Unix系统编程手册-笔记3.通用文件I/O</title><link>https://xistor.github.io/post/linux/the-linux-programming-interface-s3/</link><pubDate>Sun, 05 Jul 2020 16:01:00 +0800</pubDate><guid>https://xistor.github.io/post/linux/the-linux-programming-interface-s3/</guid><description>文件描述符：通常是一个小的非负整数，可以用来表示所有打开的文件。每个程序都会有三个标准文件描述符: File descriptor Purpose POSIX name stdio stream 0 standard input STDIN_FILENO stdin 1 standard output STDOUT_FILENO stdout 2 standard error STDERR_FILENO</description></item><item><title>Linux/Unix系统编程手册-笔记2.系统调用</title><link>https://xistor.github.io/post/linux/the-linux-programming-interface-s2/</link><pubDate>Sun, 21 Jun 2020 16:01:00 +0800</pubDate><guid>https://xistor.github.io/post/linux/the-linux-programming-interface-s2/</guid><description>系统调用 系统调用将处理器从用户态切换到核心态，以便CPU访问收到保护的内核内存。 系统调用的组成是固定的。每个系统调用都有一个唯一的数字来标识</description></item><item><title>Linux/Unix系统编程手册-笔记1.基本概念</title><link>https://xistor.github.io/post/linux/the-linux-programming-interface-s1/</link><pubDate>Thu, 28 May 2020 22:01:00 +0800</pubDate><guid>https://xistor.github.io/post/linux/the-linux-programming-interface-s1/</guid><description>简要记录整理下。 内核的职责 进程调度：Linux 属于抢占式多任务操作系统，由内核按照一定规则分配调度CPU给程序使用。 内存管理：物理内存属于有</description></item><item><title>Android 使用AIDL添加 native service</title><link>https://xistor.github.io/post/add-native-service/</link><pubDate>Wed, 27 May 2020 23:03:16 +0800</pubDate><guid>https://xistor.github.io/post/add-native-service/</guid><description>1. 下载 AOSP源码，配置编译环境 略 2. 目录结构 device下新建一个sample目录保存我们即将写的native服务,我的目录结构如下，这个s</description></item><item><title>树莓派4B USB硬盘启动</title><link>https://xistor.github.io/post/rpi4-boot-from-usb/</link><pubDate>Sun, 08 Mar 2020 22:03:16 +0800</pubDate><guid>https://xistor.github.io/post/rpi4-boot-from-usb/</guid><description>树莓派4B 官方还没有提供从USB启动的方案，不过可以使用之前更改cmdline.txt的方法实现。 我的树莓派已经使用SD卡跑了挺长时间了，不</description></item><item><title>K2路由器Pandavan配置frp实现内网穿透</title><link>https://xistor.github.io/post/k2-frp-setting/</link><pubDate>Thu, 23 Aug 2018 21:42:00 +0800</pubDate><guid>https://xistor.github.io/post/k2-frp-setting/</guid><description>树梅派跑起来后，肯定是能够随时随地访问才够方便，但是家中的宽带没有固定ip,而且pi又躲在路由器后面，因此想要访问的话必须曲线一下，有好多方</description></item></channel></rss>