<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>xistor&#39;s note</title>
    <link>https://xistor.github.io/</link>
    <description>Recent content on xistor&#39;s note</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sat, 12 Sep 2020 16:42:00 +0800</lastBuildDate>
    
	<atom:link href="https://xistor.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>网易云音乐在高分辨率下缩放问题</title>
      <link>https://xistor.github.io/post/neteasy-music-in-hdpi/</link>
      <pubDate>Sat, 12 Sep 2020 16:42:00 +0800</pubDate>
      
      <guid>https://xistor.github.io/post/neteasy-music-in-hdpi/</guid>
      <description>Linux下没几个好用的网络音乐播放器，网抑云算良心了，但是在高分屏下字体太小，根据几个博文修改--force-device-scale-f</description>
    </item>
    
    <item>
      <title>Linux/Unix系统编程手册-笔记20.定时器与休眠</title>
      <link>https://xistor.github.io/post/linux/the-linux-programming-interface-s20/</link>
      <pubDate>Wed, 02 Sep 2020 18:21:00 +0800</pubDate>
      
      <guid>https://xistor.github.io/post/linux/the-linux-programming-interface-s20/</guid>
      <description>间隔计时器 使用setitimer() #include &amp;lt;sys/time.h&amp;gt;int setitimer(int which, const struct itimerval *new_value,struct itimerval *old_value); // Returns 0 on success, or –1 on error 参数which指定不同的timer类型： ITIMER_REAL：</description>
    </item>
    
    <item>
      <title>AOSP组入Google Apps</title>
      <link>https://xistor.github.io/post/add_opengapps_to_aosp/</link>
      <pubDate>Sun, 30 Aug 2020 10:56:16 +0800</pubDate>
      
      <guid>https://xistor.github.io/post/add_opengapps_to_aosp/</guid>
      <description>自己编译好的AOSP是不包括GMS(Google Mobile Services)的，不太方便玩耍，但是有OpenGApps可以用。 官网： https://opengapps.org/ github: https://github.com/opengapps/aosp_build 环境： AO</description>
    </item>
    
    <item>
      <title>Linux/Unix系统编程手册-笔记19.信号</title>
      <link>https://xistor.github.io/post/linux/the-linux-programming-interface-s19/</link>
      <pubDate>Fri, 28 Aug 2020 18:20:00 +0800</pubDate>
      
      <guid>https://xistor.github.io/post/linux/the-linux-programming-interface-s19/</guid>
      <description>信号通常用来通知某个事件发生，一个进程(有合适的权限的话)可以给另外的进程发送信号，但大多数情况下信号是由kernel发送给进程的。 信号和软</description>
    </item>
    
    <item>
      <title>Linux/Unix系统编程手册-笔记18.监控文件事件</title>
      <link>https://xistor.github.io/post/linux/the-linux-programming-interface-s18/</link>
      <pubDate>Tue, 25 Aug 2020 18:25:00 +0800</pubDate>
      
      <guid>https://xistor.github.io/post/linux/the-linux-programming-interface-s18/</guid>
      <description>这章就只介绍了inotify机制,用来监控某个目录下的文件变化。直接看例程比较简单直接： #include &amp;lt;sys/inotify.h&amp;gt;#include &amp;lt;limits.h&amp;gt;#include &amp;#34;tlpi_hdr.h&amp;#34;static void /* 这一坨函数只是打印出变化事件 */ displayInotifyEvent(struct inotify_event *i) { printf(&amp;#34;</description>
    </item>
    
    <item>
      <title>Linux/Unix系统编程手册-笔记17.目录和链接</title>
      <link>https://xistor.github.io/post/linux/the-linux-programming-interface-s17/</link>
      <pubDate>Thu, 20 Aug 2020 18:25:00 +0800</pubDate>
      
      <guid>https://xistor.github.io/post/linux/the-linux-programming-interface-s17/</guid>
      <description>目录和硬链接 目录和文件在文件系统中大抵按照相同的方式存储，主要有两个不同点： 目录在i-node信息中会被标注成&amp;quot;目录&amp;rdquo;</description>
    </item>
    
    <item>
      <title>Linux/Unix系统编程手册-笔记16.访问控制列表</title>
      <link>https://xistor.github.io/post/linux/the-linux-programming-interface-s16/</link>
      <pubDate>Wed, 19 Aug 2020 22:40:00 +0800</pubDate>
      
      <guid>https://xistor.github.io/post/linux/the-linux-programming-interface-s16/</guid>
      <description>访问控制列表即 ACL(access control list)是对传统UNIX文件权限模型的扩展，籍此可以在每个用户或每组的基础上来控制对文件的访问。访问控制列表是利用文件扩</description>
    </item>
    
    <item>
      <title>Linux/Unix系统编程手册-笔记15.扩展属性</title>
      <link>https://xistor.github.io/post/linux/the-linux-programming-interface-s15/</link>
      <pubDate>Mon, 17 Aug 2020 15:25:00 +0800</pubDate>
      
      <guid>https://xistor.github.io/post/linux/the-linux-programming-interface-s15/</guid>
      <description>概述 文件的扩展属性(extended attributes, EAs), 允许我们给文件添加自定义的键值对属性，可以以此记录文件版本、MMIE类型信息、或文件字符编码等。 扩展</description>
    </item>
    
    <item>
      <title>Linux/Unix系统编程手册-笔记14.文件属性</title>
      <link>https://xistor.github.io/post/linux/the-linux-programming-interface-s14/</link>
      <pubDate>Sat, 15 Aug 2020 23:37:00 +0800</pubDate>
      
      <guid>https://xistor.github.io/post/linux/the-linux-programming-interface-s14/</guid>
      <description>获取文件信息 #include &amp;lt;sys/stat.h&amp;gt; int stat(const char *pathname, struct stat * statbuf); int lstat(const char *pathname, struct stat * statbuf); int fstat(int fd, struct stat *statbuf); 通过以上三个系统调用可以获取文件属性，它们大多数提取自i-node。 lstat(</description>
    </item>
    
    <item>
      <title>Pixel3 解锁bootloader</title>
      <link>https://xistor.github.io/post/unlock-the-pixel3-bootloader/</link>
      <pubDate>Sat, 15 Aug 2020 09:55:16 +0800</pubDate>
      
      <guid>https://xistor.github.io/post/unlock-the-pixel3-bootloader/</guid>
      <description>参考官方教程 https://source.android.com/setup/build/running step1 a. 进入手机设置(setting)-&amp;gt;关于手机(about phone)-&amp;gt;点击版本号(Build number) 7次 b. 输入PIN</description>
    </item>
    
    <item>
      <title>Linux/Unix系统编程手册-笔记13.文件系统</title>
      <link>https://xistor.github.io/post/linux/the-linux-programming-interface-s13/</link>
      <pubDate>Tue, 11 Aug 2020 09:49:00 +0800</pubDate>
      
      <guid>https://xistor.github.io/post/linux/the-linux-programming-interface-s13/</guid>
      <description>设备文件 一个设备文件对应一个设备，这个设备可以是真实的设备(鼠标、键盘、磁盘等)，也可以是虚拟设备。 设备分两种： 字符设备： 以字符为单位处理数</description>
    </item>
    
    <item>
      <title>Linux/Unix系统编程手册-笔记12.文件I/O缓冲</title>
      <link>https://xistor.github.io/post/linux/the-linux-programming-interface-s12/</link>
      <pubDate>Mon, 10 Aug 2020 10:53:00 +0800</pubDate>
      
      <guid>https://xistor.github.io/post/linux/the-linux-programming-interface-s12/</guid>
      <description>Overview 首先看书中的一张图，就对文件I/O缓冲有个大概的了解了： 由图所示I/O缓冲分两个层次 用户空间缓冲区，stdio的输入输出函数内部所使用的缓</description>
    </item>
    
    <item>
      <title>Linux/Unix系统编程手册-笔记11.系统和进程信息</title>
      <link>https://xistor.github.io/post/linux/the-linux-programming-interface-s11/</link>
      <pubDate>Sun, 09 Aug 2020 16:57:00 +0800</pubDate>
      
      <guid>https://xistor.github.io/post/linux/the-linux-programming-interface-s11/</guid>
      <description>现代Linux提供了/proc虚拟文件系统，开放了许多内核信息，允许进程方便的读取信息或者在某些情况下修改一些信息。/proc并不存在于磁盘</description>
    </item>
    
    <item>
      <title>Linux/Unix系统编程手册-笔记10.系统限制和选项</title>
      <link>https://xistor.github.io/post/linux/the-linux-programming-interface-s10/</link>
      <pubDate>Mon, 03 Aug 2020 10:53:00 +0800</pubDate>
      
      <guid>https://xistor.github.io/post/linux/the-linux-programming-interface-s10/</guid>
      <description>系统限制和选项在不同系统实现、不同的运行环境、不同的文件系统之间可能存在不同。 程序获取限制值有两种途径： 在编译程序时能获得一些限制和选项，例</description>
    </item>
    
    <item>
      <title>Linux/Unix系统编程手册-笔记9.时间</title>
      <link>https://xistor.github.io/post/linux/the-linux-programming-interface-s9/</link>
      <pubDate>Thu, 30 Jul 2020 10:53:00 +0800</pubDate>
      
      <guid>https://xistor.github.io/post/linux/the-linux-programming-interface-s9/</guid>
      <description>直接看书上的例子吧：获取时间并转换成多种形式显示。加了些注释。 #include &amp;lt;locale.h&amp;gt;#include &amp;lt;time.h&amp;gt;#include &amp;lt;sys/time.h&amp;gt;#include &amp;#34;tlpi_hdr.h&amp;#34; #define SECONDS_IN_TROPICAL_YEAR (365.24219 * 24 * 60 * 60) int main(int argc, char *argv[]) { time_t t; struct tm *gmp, *locp; struct tm gm, loc; struct timeval tv; /* Retrieve time, convert and display</description>
    </item>
    
    <item>
      <title>Linux/Unix系统编程手册-笔记8.进程信任状态</title>
      <link>https://xistor.github.io/post/linux/the-linux-programming-interface-s8/</link>
      <pubDate>Tue, 28 Jul 2020 10:53:00 +0800</pubDate>
      
      <guid>https://xistor.github.io/post/linux/the-linux-programming-interface-s8/</guid>
      <description>每个进程有一组相关的UID和GID: 真实用户ID(real user ID)和组ID 有效用户ID(effective user ID)和组ID 保存的set-us</description>
    </item>
    
    <item>
      <title>Linux/Unix系统编程手册-笔记7.用户和组</title>
      <link>https://xistor.github.io/post/linux/the-linux-programming-interface-s7/</link>
      <pubDate>Mon, 27 Jul 2020 10:53:00 +0800</pubDate>
      
      <guid>https://xistor.github.io/post/linux/the-linux-programming-interface-s7/</guid>
      <description>本章没啥好说的，比较有意思的的是crypt()函数，可以用来做用户身份鉴别： #define _XOPEN_SOURCE #include &amp;lt;unistd.h&amp;gt;char *crypt(const char *key, const char *salt); /* Returns pointer to statically allocated string containing encrypted password on success, or NULL on error */ crypt</description>
    </item>
    
    <item>
      <title>Linux/Unix系统编程手册-笔记6.内存分配</title>
      <link>https://xistor.github.io/post/linux/the-linux-programming-interface-s6/</link>
      <pubDate>Sat, 25 Jul 2020 10:53:00 +0800</pubDate>
      
      <guid>https://xistor.github.io/post/linux/the-linux-programming-interface-s6/</guid>
      <description>在堆上分配内存 系统提供了两个改变堆大小的系统调用：brk()和sbrk() int brk(void *end_data_segment); // return 0 on success or -1 on error void *sbrk(intptr_t increment); // return previous progrom break on success, or (void *) -1 on error brk()</description>
    </item>
    
    <item>
      <title>Linux/Unix系统编程手册-笔记5.进程</title>
      <link>https://xistor.github.io/post/linux/the-linux-programming-interface-s5/</link>
      <pubDate>Thu, 16 Jul 2020 14:01:00 +0800</pubDate>
      
      <guid>https://xistor.github.io/post/linux/the-linux-programming-interface-s5/</guid>
      <description>进程和程序 进程是一个运行中的程序实例，一个程序中包含了如何构建一个进程的信息，这些信息包括： 二进制格式识别信息：每个程序都包含了元信息来描述</description>
    </item>
    
    <item>
      <title>Linux/Unix系统编程手册-笔记4.深入探究文件I/O</title>
      <link>https://xistor.github.io/post/linux/the-linux-programming-interface-s4/</link>
      <pubDate>Sun, 12 Jul 2020 16:01:00 +0800</pubDate>
      
      <guid>https://xistor.github.io/post/linux/the-linux-programming-interface-s4/</guid>
      <description>原子操作与竞争条件 创建文件 当同时指定O_EXCL和O_CREAT作为open()的标志位时，如果要打开文件已然存在，open()将返回一个错</description>
    </item>
    
    <item>
      <title>Linux/Unix系统编程手册-笔记3.通用文件I/O</title>
      <link>https://xistor.github.io/post/linux/the-linux-programming-interface-s3/</link>
      <pubDate>Sun, 05 Jul 2020 16:01:00 +0800</pubDate>
      
      <guid>https://xistor.github.io/post/linux/the-linux-programming-interface-s3/</guid>
      <description>文件描述符：通常是一个小的非负整数，可以用来表示所有打开的文件。每个程序都会有三个标准文件描述符: File descriptor Purpose POSIX name stdio stream 0 standard input STDIN_FILENO stdin 1 standard output STDOUT_FILENO stdout 2 standard error STDERR_FILENO</description>
    </item>
    
    <item>
      <title>Linux/Unix系统编程手册-笔记2.系统调用</title>
      <link>https://xistor.github.io/post/linux/the-linux-programming-interface-s2/</link>
      <pubDate>Sun, 21 Jun 2020 16:01:00 +0800</pubDate>
      
      <guid>https://xistor.github.io/post/linux/the-linux-programming-interface-s2/</guid>
      <description>系统调用 系统调用将处理器从用户态切换到核心态，以便CPU访问收到保护的内核内存。 系统调用的组成是固定的。每个系统调用都有一个唯一的数字来标识</description>
    </item>
    
    <item>
      <title>Linux/Unix系统编程手册-笔记1.基本概念</title>
      <link>https://xistor.github.io/post/linux/the-linux-programming-interface-s1/</link>
      <pubDate>Thu, 28 May 2020 22:01:00 +0800</pubDate>
      
      <guid>https://xistor.github.io/post/linux/the-linux-programming-interface-s1/</guid>
      <description>简要记录整理下。 内核的职责 进程调度：Linux 属于抢占式多任务操作系统，由内核按照一定规则分配调度CPU给程序使用。 内存管理：物理内存属于有</description>
    </item>
    
    <item>
      <title>Android 使用AIDL添加 native service</title>
      <link>https://xistor.github.io/post/add-native-service/</link>
      <pubDate>Wed, 27 May 2020 23:03:16 +0800</pubDate>
      
      <guid>https://xistor.github.io/post/add-native-service/</guid>
      <description>1. 下载 AOSP源码，配置编译环境 略 2. 目录结构 device下新建一个sample目录保存我们即将写的native服务,我的目录结构如下，这个s</description>
    </item>
    
    <item>
      <title>树莓派4B USB硬盘启动</title>
      <link>https://xistor.github.io/post/rpi4-boot-from-usb/</link>
      <pubDate>Sun, 08 Mar 2020 22:03:16 +0800</pubDate>
      
      <guid>https://xistor.github.io/post/rpi4-boot-from-usb/</guid>
      <description>树莓派4B 官方还没有提供从USB启动的方案，不过可以使用之前更改cmdline.txt的方法实现。 我的树莓派已经使用SD卡跑了挺长时间了，不</description>
    </item>
    
    <item>
      <title>K2路由器Pandavan配置frp实现内网穿透</title>
      <link>https://xistor.github.io/post/k2-frp-setting/</link>
      <pubDate>Thu, 23 Aug 2018 21:42:00 +0800</pubDate>
      
      <guid>https://xistor.github.io/post/k2-frp-setting/</guid>
      <description>树梅派跑起来后，肯定是能够随时随地访问才够方便，但是家中的宽带没有固定ip,而且pi又躲在路由器后面，因此想要访问的话必须曲线一下，有好多方</description>
    </item>
    
  </channel>
</rss>