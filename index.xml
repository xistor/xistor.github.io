<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>xistor&#39;s note</title>
    <link>https://xistor.github.io/</link>
    <description>Recent content on xistor&#39;s note</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sun, 09 Aug 2020 16:57:00 +0800</lastBuildDate>
    
	<atom:link href="https://xistor.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Linux/Unix系统编程手册-笔记11.系统和进程信息</title>
      <link>https://xistor.github.io/post/linux/the-linux-programming-interface-s11/</link>
      <pubDate>Sun, 09 Aug 2020 16:57:00 +0800</pubDate>
      
      <guid>https://xistor.github.io/post/linux/the-linux-programming-interface-s11/</guid>
      <description>现代Linux提供了/proc虚拟文件系统，开放了许多内核信息，允许进程方便的读取信息或者在某些情况下修改一些信息。/proc并不存在于磁盘</description>
    </item>
    
    <item>
      <title>Linux/Unix系统编程手册-笔记10.系统限制和选项</title>
      <link>https://xistor.github.io/post/linux/the-linux-programming-interface-s10/</link>
      <pubDate>Mon, 03 Aug 2020 10:53:00 +0800</pubDate>
      
      <guid>https://xistor.github.io/post/linux/the-linux-programming-interface-s10/</guid>
      <description>系统限制和选项在不同系统实现、不同的运行环境、不同的文件系统之间可能存在不同。 程序获取限制值有两种途径： 在编译程序时能获得一些限制和选项，例</description>
    </item>
    
    <item>
      <title>Linux/Unix系统编程手册-笔记9.时间</title>
      <link>https://xistor.github.io/post/linux/the-linux-programming-interface-s9/</link>
      <pubDate>Thu, 30 Jul 2020 10:53:00 +0800</pubDate>
      
      <guid>https://xistor.github.io/post/linux/the-linux-programming-interface-s9/</guid>
      <description>直接看书上的例子吧：获取时间并转换成多种形式显示。加了些注释。 #include &amp;lt;locale.h&amp;gt;#include &amp;lt;time.h&amp;gt;#include &amp;lt;sys/time.h&amp;gt;#include &amp;#34;tlpi_hdr.h&amp;#34; #define SECONDS_IN_TROPICAL_YEAR (365.24219 * 24 * 60 * 60) int main(int argc, char *argv[]) { time_t t; struct tm *gmp, *locp; struct tm gm, loc; struct timeval tv; /* Retrieve time, convert and display</description>
    </item>
    
    <item>
      <title>Linux/Unix系统编程手册-笔记8.进程信任状态</title>
      <link>https://xistor.github.io/post/linux/the-linux-programming-interface-s8/</link>
      <pubDate>Tue, 28 Jul 2020 10:53:00 +0800</pubDate>
      
      <guid>https://xistor.github.io/post/linux/the-linux-programming-interface-s8/</guid>
      <description>每个进程有一组相关的UID和GID: 真实用户ID(real user ID)和组ID 有效用户ID(effective user ID)和组ID 保存的set-us</description>
    </item>
    
    <item>
      <title>Linux/Unix系统编程手册-笔记7.用户和组</title>
      <link>https://xistor.github.io/post/linux/the-linux-programming-interface-s7/</link>
      <pubDate>Mon, 27 Jul 2020 10:53:00 +0800</pubDate>
      
      <guid>https://xistor.github.io/post/linux/the-linux-programming-interface-s7/</guid>
      <description>本章没啥好说的，比较有意思的的是crypt()函数，可以用来做用户身份鉴别： #define _XOPEN_SOURCE #include &amp;lt;unistd.h&amp;gt;char *crypt(const char *key, const char *salt); /* Returns pointer to statically allocated string containing encrypted password on success, or NULL on error */ crypt</description>
    </item>
    
    <item>
      <title>Linux/Unix系统编程手册-笔记6.内存分配</title>
      <link>https://xistor.github.io/post/linux/the-linux-programming-interface-s6/</link>
      <pubDate>Sat, 25 Jul 2020 10:53:00 +0800</pubDate>
      
      <guid>https://xistor.github.io/post/linux/the-linux-programming-interface-s6/</guid>
      <description>在堆上分配内存 系统提供了两个改变堆大小的系统调用：brk()和sbrk() int brk(void *end_data_segment); // return 0 on success or -1 on error void *sbrk(intptr_t increment); // return previous progrom break on success, or (void *) -1 on error brk()</description>
    </item>
    
    <item>
      <title>Linux/Unix系统编程手册-笔记5.进程</title>
      <link>https://xistor.github.io/post/linux/the-linux-programming-interface-s5/</link>
      <pubDate>Thu, 16 Jul 2020 14:01:00 +0800</pubDate>
      
      <guid>https://xistor.github.io/post/linux/the-linux-programming-interface-s5/</guid>
      <description>进程和程序 进程是一个运行中的程序实例，一个程序中包含了如何构建一个进程的信息，这些信息包括： 二进制格式识别信息：每个程序都包含了元信息来描述</description>
    </item>
    
    <item>
      <title>Linux/Unix系统编程手册-笔记4.深入探究文件I/O</title>
      <link>https://xistor.github.io/post/linux/the-linux-programming-interface-s4/</link>
      <pubDate>Sun, 12 Jul 2020 16:01:00 +0800</pubDate>
      
      <guid>https://xistor.github.io/post/linux/the-linux-programming-interface-s4/</guid>
      <description>原子操作与竞争条件 创建文件 当同时指定O_EXCL和O_CREAT作为open()的标志位时，如果要打开文件已然存在，open()将返回一个错</description>
    </item>
    
    <item>
      <title>Linux/Unix系统编程手册-笔记3.通用文件I/O</title>
      <link>https://xistor.github.io/post/linux/the-linux-programming-interface-s3/</link>
      <pubDate>Sun, 05 Jul 2020 16:01:00 +0800</pubDate>
      
      <guid>https://xistor.github.io/post/linux/the-linux-programming-interface-s3/</guid>
      <description>文件描述符：通常是一个小的非负整数，可以用来表示所有打开的文件。每个程序都会有三个标准文件描述符: File descriptor Purpose POSIX name stdio stream 0 standard input STDIN_FILENO stdin 1 standard output STDOUT_FILENO stdout 2 standard error STDERR_FILENO</description>
    </item>
    
    <item>
      <title>Linux/Unix系统编程手册-笔记2.系统调用</title>
      <link>https://xistor.github.io/post/linux/the-linux-programming-interface-s2/</link>
      <pubDate>Sun, 21 Jun 2020 16:01:00 +0800</pubDate>
      
      <guid>https://xistor.github.io/post/linux/the-linux-programming-interface-s2/</guid>
      <description>系统调用 系统调用将处理器从用户态切换到核心态，以便CPU访问收到保护的内核内存。 系统调用的组成是固定的。每个系统调用都有一个唯一的数字来标识</description>
    </item>
    
    <item>
      <title>Linux/Unix系统编程手册-笔记1.基本概念</title>
      <link>https://xistor.github.io/post/linux/the-linux-programming-interface-s1/</link>
      <pubDate>Thu, 28 May 2020 22:01:00 +0800</pubDate>
      
      <guid>https://xistor.github.io/post/linux/the-linux-programming-interface-s1/</guid>
      <description>简要记录整理下。 内核的职责 进程调度：Linux 属于抢占式多任务操作系统，由内核按照一定规则分配调度CPU给程序使用。 内存管理：物理内存属于有</description>
    </item>
    
    <item>
      <title>Android 使用AIDL添加 native service</title>
      <link>https://xistor.github.io/post/add-native-service/</link>
      <pubDate>Wed, 27 May 2020 23:03:16 +0800</pubDate>
      
      <guid>https://xistor.github.io/post/add-native-service/</guid>
      <description>1. 下载 AOSP源码，配置编译环境 略 2. 目录结构 device下新建一个sample目录保存我们即将写的native服务,我的目录结构如下，这个s</description>
    </item>
    
    <item>
      <title>树莓派4B USB硬盘启动</title>
      <link>https://xistor.github.io/post/rpi4-boot-from-usb/</link>
      <pubDate>Sun, 08 Mar 2020 22:03:16 +0800</pubDate>
      
      <guid>https://xistor.github.io/post/rpi4-boot-from-usb/</guid>
      <description>树莓派4B 官方还没有提供从USB启动的方案，不过可以使用之前更改cmdline.txt的方法实现。 我的树莓派已经使用SD卡跑了挺长时间了，不</description>
    </item>
    
    <item>
      <title>K2路由器Pandavan配置frp实现内网穿透</title>
      <link>https://xistor.github.io/post/k2-frp-setting/</link>
      <pubDate>Thu, 23 Aug 2018 21:42:00 +0800</pubDate>
      
      <guid>https://xistor.github.io/post/k2-frp-setting/</guid>
      <description>树梅派跑起来后，肯定是能够随时随地访问才够方便，但是家中的宽带没有固定ip,而且pi又躲在路由器后面，因此想要访问的话必须曲线一下，有好多方</description>
    </item>
    
  </channel>
</rss>